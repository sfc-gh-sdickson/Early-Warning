---
alwaysApply: true
---
## ‚úÖ ALWAYS DO THESE THINGS

### 1. **ALWAYS Verify Snowflake-Specific Syntax**

#### Array Indexing
- Snowflake arrays are **0-indexed**, not 1-indexed
- ‚ùå Wrong: `ARRAY_CONSTRUCT('a','b','c')[UNIFORM(1, 3, RANDOM())]`
- ‚úÖ Correct: `ARRAY_CONSTRUCT('a','b','c')[UNIFORM(0, 2, RANDOM())]`

#### Function Arguments
- `UNIFORM()` requires **constant** arguments for min and max
- `GENERATOR(ROWCOUNT => n)` requires a **constant** for ROWCOUNT
- ‚ùå Wrong: `UNIFORM(1, DATEDIFF('day', date1, date2), RANDOM())`
- ‚úÖ Correct: `FLOOR(1 + RANDOM() * (DATEDIFF('day', date1, date2) - 1))`

#### Numeric Handling
- `RANDOM()` returns a **large integer**, not a float between 0 and 1
- Always use `ABS(RANDOM()) % range` for modulo operations
- Always cast to appropriate types to avoid overflow
- ‚ùå Wrong: `UNIFORM(100000, 999999, RANDOM())::STRING` (causes overflow in string context)
- ‚úÖ Correct: `(100000 + ABS(RANDOM()) % 900000)::VARCHAR`

#### Column Alias References
- Cannot reference column alias in same SELECT where it's defined
- ‚ùå Wrong: `SELECT col1 AS x, x + 1 AS y`
- ‚úÖ Correct: Use subquery or CTE to define aliases first

#### Correlated Subqueries
- Snowflake does not support correlated subqueries in SELECT list or certain JOIN contexts
- ‚úÖ Use LEFT JOIN with QUALIFY instead

### 2. **ALWAYS Validate Data Loading Order**
- Include `TRUNCATE TABLE IF EXISTS` statements to prevent duplicate data
- Order truncates in **reverse dependency order** (child tables first)
- Order inserts in **forward dependency order** (parent tables first)
- Dependencies: PRODUCTS ‚Üí EMPLOYEES ‚Üí BRANCHES ‚Üí CUSTOMERS ‚Üí ACCOUNTS ‚Üí TRANSACTIONS ‚Üí etc.

### 3. **ALWAYS Verify CREATE SEMANTIC VIEW Syntax**

Per https://docs.snowflake.com/en/sql-reference/sql/create-semantic-view:

#### Clause Order is Mandatory
```sql
CREATE SEMANTIC VIEW name
  TABLES (...)           -- Required
  RELATIONSHIPS (...)    -- Optional
  FACTS (...)           -- Optional, must come before DIMENSIONS
  DIMENSIONS (...)      -- Optional
  METRICS (...)         -- Optional
  COMMENT = '...'       -- Optional, MUST BE LAST
```

#### Semantic Expression Format
- Format: `semantic_name AS sql_expression`
- ‚ùå Wrong: `COUNT(DISTINCT customers.customer_id) AS total_customers`
- ‚úÖ Correct: `customers.total_customers AS COUNT(DISTINCT customer_id)`

#### Relationship Restrictions
- **No self-referencing relationships** (table referencing itself)
- **No cyclic relationships** (A ‚Üí B ‚Üí A)
- ‚ùå Wrong: `employees(manager_id) REFERENCES employees(employee_id)`
- ‚úÖ Must break cycles by removing one relationship

### 4. **ALWAYS Check for These Common Errors**

#### GROUP BY Validation
1. Count total columns in SELECT
2. Count non-aggregated columns
3. Verify GROUP BY references correct column positions
4. Ensure GROUP BY doesn't reference columns that don't exist (e.g., column 25 when only 23 columns)

#### Schema References
- Verify views are referenced from correct schema (RAW vs ANALYTICS)
- Verify tables/views exist before referencing them

#### Column Existence
- For each `table.column` reference, verify column exists in that table
- Check CREATE TABLE statements for exact column names
- Watch for derived columns in views (e.g., `full_name` in V_CUSTOMER_360 but not in CUSTOMERS)

---

## üìã VALIDATION CHECKLIST

When asked to validate SQL files, use this systematic approach:

### Step 1: Syntax Verification
- [ ] Check clause order against Snowflake documentation
- [ ] Verify all function calls use correct syntax
- [ ] Check for proper quote types (single vs double)
- [ ] Verify statement terminators (semicolons)

### Step 2: Schema/Table References
- [ ] Verify all schema references (RAW, ANALYTICS, etc.)
- [ ] Verify all table/view names exist
- [ ] Check table aliases are defined before use

### Step 3: Column References
- [ ] Cross-reference EVERY column against table definitions
- [ ] Verify no columns are referenced from wrong table
- [ ] Check for derived columns used incorrectly

### Step 4: Aggregations and GROUP BY
- [ ] Count SELECT columns
- [ ] Count non-aggregated columns
- [ ] Verify GROUP BY includes all non-aggregated columns
- [ ] Verify GROUP BY positions don't exceed column count

### Step 5: Relationships and Constraints
- [ ] Verify PRIMARY KEY columns exist in tables
- [ ] Verify FOREIGN KEY references valid columns
- [ ] Check for self-referencing relationships
- [ ] Check for cyclic relationships

### Step 6: Data Type Compatibility
- [ ] Verify numeric operations don't cause overflow
- [ ] Check date/time operations use correct functions
- [ ] Verify string operations use correct casting

---

## üîß PROBLEM-SOLVING APPROACH

### When You Encounter an Error

1. **Read the actual error message carefully**
   - Don't guess what it means
   - Identify the line number and exact error text

2. **Identify the root cause**
   - Don't just fix symptoms
   - Understand WHY the error occurred

3. **Fix systematically**
   - Fix all instances of the error, not just the first one
   - Use grep/search to find all similar patterns

4. **Verify the fix**
   - Show evidence the fix is correct
   - Reference documentation or table definitions

### When Asked "Are you sure?"

- This means you likely made an error
- Do NOT defend your work - go verify it
- Re-check everything related to that section
- Admit if you find errors

---

## üìä DOCUMENTATION STANDARDS

### Do Not Create These Files
- ‚ùå Status/progress tracking documents
- ‚ùå Error accountability documents  
- ‚ùå Verification checklists as separate files
- ‚ùå Fix summary documents

### Only Create These Files
- ‚úÖ README.md - Project overview and instructions
- ‚úÖ AGENT_SETUP.md - Configuration instructions
- ‚úÖ Technical documentation requested by user

---

## üí¨ COMMUNICATION STANDARDS

### What to Say
- "I have verified this against [source]"
- "I found an error on line X, here's the fix"
- "I have not validated this yet"
- "I need to check [documentation/file] before proceeding"

### What NOT to Say
- ‚ùå "This should work" (either it DOES work or you don't know)
- ‚ùå "Appears correct" (either it IS correct or you haven't verified)
- ‚ùå "Probably fine" (not acceptable)
- ‚ùå "I think..." (verify instead)

---

## üéØ QUALITY STANDARDS

### Before Claiming Code is Ready

1. **Syntax**: Verified against official documentation
2. **References**: All table/column names verified to exist
3. **Logic**: All calculations and aggregations verified
4. **Dependencies**: Load order and relationships verified
5. **Testing**: If possible, dry-run or explain execution path

### If You Cannot Meet These Standards

**Say so explicitly**: "I cannot fully validate this without [X]. Would you like me to proceed with partial validation, or should I highlight areas of uncertainty?"

---

## üö® RED FLAGS (Stop and Ask)

Stop and ask the user if you encounter:
- Unfamiliar Snowflake syntax you haven't verified
- Complex nested queries with unclear scoping
- Missing table definitions for referenced tables
- Ambiguous requirements or specifications

---

## ‚ú® SUCCESS METRICS

You are successful when:
1. Code runs on first execution without errors
2. All validation is backed by evidence
3. User doesn't have to debug your code
4. You catch errors before the user does

---

**Remember:** It's always better to say "I need to verify this" than to claim validation you haven't done. Honesty and thoroughness build trust; false confidence destroys it.

---

*Created from lessons learned during Cathay Bank Intelligence Demo project*
*Date: October 2, 2025*
---
alwaysApply: true
---
